# [HTTP](https://www.rfc-editor.org/rfc/rfc9110#name-introduction)

# Web server :

A web server is a software or hardware system that serves web content to clients over the internet or an intranet. It handles HTTP (Hypertext Transfer Protocol) requests from clients (typically web browsers) and provides the appropriate responses, usually in the form of web pages (HTML), images, scripts, or other media.

Here are some key aspects and functions of a web server:

1. **Handling Requests**: The primary role of a web server is to listen for incoming HTTP/HTTPS requests from clients and respond to them appropriately. This involves accepting a connection, reading the request, processing it, and sending back the appropriate response.

2. **Serving Content**: Web servers serve various types of content, such as HTML documents, images, stylesheets (CSS), JavaScript files, video, and other multimedia. They can serve static content directly from the file system or dynamic content generated by server-side scripts.

3. **Processing Dynamic Content**: Many web servers can interface with server-side scripting languages (such as PHP, Python, Ruby, or Node.js) to generate dynamic content. For instance, when a request for a PHP page is received, the web server passes the request to the PHP interpreter, processes the script, and returns the output to the client.

4. **Managing Connections**: Web servers manage multiple connections simultaneously, often using multithreading or asynchronous I/O to handle many requests at once. This is crucial for maintaining performance and responsiveness, especially under heavy load.

5. **Security Features**: Web servers support various security features, such as HTTPS (HTTP Secure) for encrypted communication, authentication, access control, and protection against common web vulnerabilities (like SQL injection, cross-site scripting, etc.).

6. **Logging and Monitoring**: Web servers typically include logging features to record details about incoming requests, errors, and other significant events. These logs are valuable for troubleshooting, performance monitoring, and security auditing.

### Popular Web Servers

**Apache HTTP Server** , **Nginx** , **Microsoft Internet Information Services (IIS)**

### How a Web Server Works

1. **Client Request**: The process starts when a client (e.g., a web browser) makes a request to the web server. This request is typically initiated by entering a URL in the browser's address bar or by clicking on a link.

2. **DNS Resolution**: The domain name in the URL is resolved to an IP address via the Domain Name System (DNS).

3. **Connection Establishment**: The client establishes a TCP connection with the web server using the resolved IP address and port 80 (for HTTP) or port 443 (for HTTPS).

4. **Request Handling**: The client sends an HTTP request to the server, specifying the desired resource (e.g., a web page, image, or script).

5. **Response Generation**: The web server processes the request, retrieves the requested resource (or generates it dynamically), and sends an HTTP response back to the client.

6. **Connection Termination**: Depending on the HTTP version and headers, the connection may be closed immediately after the response is sent, or it may be kept open for further requests (persistent connections).

By efficiently handling these steps, a web server ensures that users can access and interact with web content quickly and reliably.

# OSI Model (Open System Interconnection model)

The OSI model is a conceptual framework that standardizes the functions of a telecommunication or computing system into seven abstraction layers. It divides the communication process into smaller and simpler components, enabling easier troubleshooting and development of interoperable systems.

The seven layers of the OSI model are:

1. **Physical Layer**: The physical layer deals with the physical connection between devices. It defines the hardware and transmission medium used to transmit data.

2. **Data Link Layer**: The data link layer establishes and terminates connections between devices. It ensures data integrity and provides error detection and correction.

3. **Network Layer**: The network layer handles routing and forwarding of data packets between devices. It determines the best path for data to travel from the source to the destination.

4. **Transport Layer**: The transport layer ensures reliable data transfer between devices. It manages end-to-end communication, error recovery, and flow control.

5. **Session Layer**: The session layer establishes, maintains, and terminates sessions between devices. It manages the communication sessions and synchronization between applications.

6. **Presentation Layer**: The presentation layer translates data into a format that the application layer can understand. It handles data encryption, compression, and formatting.

7. **Application Layer**: The application layer provides an interface for user applications to access network services. It enables communication between software applications and network services.

The OSI model helps in understanding how different networking protocols and technologies interact and provides a common reference point for network design and troubleshooting.

# IP

The Internet Protocol (IP) is the address system of the Internet and has the core function of delivering packets of information from a source device to a target device.
IP doesn't handel packet ordering or error check for this we use TCP(Transmission control protocol).

IP is a connectionless protocol, which means that each unit of data is individually addressed and routed from the source device to the target device, and the target does not send an acknowledgement back to the source. That’s where protocols such as TCP come in. TCP is used in conjunction with IP in order to maintain a connection between the sender and the target and to ensure packet order.

# TCP

The Transmission Control Protocol (TCP) is a core protocol of the Internet Protocol Suite. It operates at a higher level than its compatriot, the Internet Protocol (IP), which is a lower-level protocol.
TCP is a connection-oriented protocol, which means that a connection is established and maintained until the application programs at each end have finished exchanging messages. It determines how to break application data into packets that networks can deliver, sends packets to and accepts packets from the network layer, manages flow control, and—because it is meant to provide error-free data transmission—handles retransmission of dropped or garbled packets as well as acknowledgement of all packets that arrive.

# TCP Layers Concepts

1. **Application Layer**: This is the layer where the actual communication happens. It is the layer that the user interacts with. It is responsible for the data exchange between the user and the server. It is the layer where the data is converted into a format that can be sent over the network.

# Thread Pooling in web server

- Thread pooling is a technique used in computer programming to manage and reuse a pool of threads for executing tasks. Instead of creating a new thread for each task, a thread pool maintains a set of worker threads that are ready to execute tasks when needed. This approach improves performance by reducing the overhead of creating and destroying threads for each task.

- In the context of a web server, thread pooling can be used to handle multiple incoming client requests concurrently. When a request arrives, it is assigned to an available worker thread from the pool, which processes the request and sends a response back to the client. Once the task is completed, the worker thread is returned to the pool for reuse.

- Thread pooling offers several benefits for web servers:

  1. **Improved Performance**: By reusing threads, the server can handle multiple requests more efficiently, reducing the overhead of thread creation and destruction.

  2. **Resource Management**: Thread pooling helps manage system resources effectively by limiting the number of active threads and preventing resource exhaustion.

  3. **Scalability**: Thread pooling allows the server to scale to handle a larger number of concurrent requests without overwhelming the system.

  4. **Concurrency Control**: Thread pooling provides a mechanism to control the number of concurrent tasks being executed, preventing the server from becoming overloaded.

  5. **Responsiveness**: By maintaining a pool of worker threads, the server can respond quickly to incoming requests without the delay of creating new threads.

# Http Pipelingin

- HTTP pipelining is a technique in which multiple HTTP requests are sent over a single TCP connection without waiting for the corresponding responses. This allows multiple requests to be sent in rapid succession, potentially improving the overall performance of the communication.

- In a typical HTTP request-response cycle, the client sends a request to the server and waits for the response before sending the next request. With HTTP pipelining, the client can send multiple requests without waiting for the responses, which can reduce the latency of the communication.

- The server processes the requests in the order they are received and sends back the responses in the same order. This can lead to more efficient use of the network connection and faster delivery of content to the client.

- However, HTTP pipelining has some limitations and potential issues:

  1. **Head-of-Line Blocking**: If one request in the pipeline encounters a delay or error, it can block subsequent requests from being processed, leading to a performance bottleneck.

  2. **Out-of-Order Responses**: In some cases, responses may arrive out of order, requiring the client to reorder them before processing.

  3. **Compatibility**: Not all servers and clients support HTTP pipelining, so it may not be widely used in practice.

- Despite these limitations, HTTP pipelining can be a useful optimization technique in certain scenarios where the benefits outweigh the drawbacks. It is important to consider the specific requirements and constraints of the application when deciding whether to use HTTP pipelining.

# E-tag/Web Caching

- ETag (Entity Tag) is an HTTP response header that provides a mechanism for web servers to validate web cache entries (also known as web caches) and determine if the content has changed since the last request. ETags are used to reduce bandwidth usage, server load, and network latency by allowing browsers to cache resources more effectively.

- ## HTTP Response :

  ```
  HTTP/1.1 200 OK\r\n
  Content-Type: text/html\r\n
  Content-Length: 23\r\n
  \r\n
  <html>\r\n
  <body>\r\n
  Hello, World!\r\n
  </body>\r\n
  </html>\r\n
  ```

  The headers are:

  1. `HTTP/1.1 200 OK`
  2. `Content-Type: text/html`
  3. `Content-Length: 23`

  The body starts after the blank line (`\r\n\r\n`). So, the body in this example is:

  ```
  <html>\r\n
  <body>\r\n
  Hello, World!\r\n
  </body>\r\n
  </html>\r\n
  ```

  Headers and body are separated by the double `\r\n`, which indicates the end of the headers and the beginning of the body.

- ## HTTP Request

  An HTTP request is a message sent by a client to a web server to request resources such as HTML pages, images, or data from a database. The structure of an HTTP request includes several key components:

  1. **Request Line**: Specifies the HTTP method (e.g., GET, POST), the resource being requested (URL), and the HTTP version.
  2. **Headers**: Provide additional information about the request, such as the type of data being sent, the client's user-agent, and other metadata.
  3. **Body**: Contains the data being sent to the server (only present in methods like POST, PUT, etc.).

  ### Structure of an HTTP Request

  #### 1. Request Line

  The request line includes:

  - **HTTP Method**: The action to be performed (e.g., GET, POST, PUT, DELETE).
  - **Request-URI**: The path to the resource.
  - **HTTP Version**: The version of the HTTP protocol being used (e.g., HTTP/1.1).

  #### 2. Headers

  HTTP headers provide additional information about the request. Common headers include:

  - **Host**: The domain name of the server.
  - **User-Agent**: Information about the client (e.g., browser type and version).
  - **Accept**: The types of responses the client can accept (e.g., text/html, application/json).
  - **Content-Type**: The media type of the body of the request (used in POST and PUT requests).

  #### 3. Body

  The body of the request is used to send data to the server. This is typically used in POST, PUT, and PATCH requests.

  ### Example of an HTTP Request

  Here's an example of an HTTP GET request to fetch a webpage:

  ```
  GET /index.html HTTP/1.1
  Host: www.example.com
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
  Accept-Language: en-US,en;q=0.5
  Accept-Encoding: gzip, deflate
  Connection: keep-alive
  ```

  In this example:

  - **GET**: The HTTP method, indicating that the client wants to retrieve the resource.
  - **/index.html**: The resource being requested.
  - **HTTP/1.1**: The HTTP version.
  - **Host**: Specifies the domain name of the server.
  - **User-Agent**: Identifies the client software making the request.
  - **Accept**: Lists the types of content the client can process.
  - **Accept-Language**: Indicates the client's preferred languages.
  - **Accept-Encoding**: Specifies the content encodings the client can handle.
  - **Connection**: Controls whether the network connection stays open after the current transaction.

  ### Example of an HTTP POST Request

  Here's an example of an HTTP POST request to submit form data:

  ```
  POST /submit-form HTTP/1.1
  Host: www.example.com
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
  Accept-Language: en-US,en;q=0.5
  Accept-Encoding: gzip, deflate
  Content-Type: application/x-www-form-urlencoded
  Content-Length: 27
  Connection: keep-alive

  name=JohnDoe&age=30
  ```

  In this example:

  - **POST**: The HTTP method, indicating that the client wants to send data to the server.
  - **/submit-form**: The resource being targeted.
  - **Content-Type**: Indicates that the body content is form-encoded.
  - **Content-Length**: Specifies the length of the request body.
  - **Body**: Contains the form data (`name=JohnDoe&age=30`).

# User Agent header

- [Read Here..](https://developer.mozilla.org/en-US/docs/Glossary/User_agent)
- User-Agent is an identifier used by browser that is used to represent browser name, os name and other thing to the webserver whenever it makes request, Not only Browser uses user/agent web scraper and download manager and other apps accessing the web.

# Thread & MultiThreading

## Multithreading is a feature that allows concurrent or simultaneous execution of two or more parts of a program for maximum utilization of the CPU. Each part of such a program is called a thread. So, `Threads are lightweight processes within a process`.

## C++ 11 Provide std::thread and define in <thread> .

```cpp
    std::thread thread_object (pointer of function);
```

- std::thread is the thread class that represents a single thread in C++. To start a thread we simply need to create a new thread object and pass the executing code to be called (i.e, a callable object) into the constructor of the object. Once the object is created a new thread is launched which will execute the code specified in callable. A callable can be `Pointer of function` and other things.

### Examples :

```cpp
void foo(param)
{
  Statements;
}
// The parameters to the function are put after the comma
std::thread thread_obj(foo, params);
```

### Every Thread object must go through detach and join if not lead to error.

- ### Join

  - It waits or hault the program until that thread on which join function is called will complete it execution and then goes to next thread or if there is no other thread goes to main function thread.

  Example :

```cpp

    void foo(int Z)
    {
        for (int i = 0; i < Z; i++) {
            cout << "Thread using function"
                    " pointer as callable\n";
        }
        std::this_thread::sleep_for(chrono:seconds(5));
    }


    int main()
    {
        cout << "Threads 1 "
                "operating independently"
            << endl;

        // This thread is launched by using
        // function pointer as callable
        thread th1(foo, 3);
        th1.join();
        return 0;
    }

```

- ### Detach

  - It is used to detach the newly created thread fromt the parent thread , Always check before detaching a thread that it is joinable otherwise we may end up double detaching and double detach willresult into program execution.

```cpp

    void foo(int Z)
    {
        for (int i = 0; i < Z; i++) {
            cout << "Thread using function"
                    " pointer as callable\n";
        }
        std::this_thread::sleep_for(chrono:seconds(5));
    }


    int main()
    {
        cout << "Threads 1 "
                "operating independently"
            << endl;

        // This thread is launched by using
        // function pointer as callable
        thread th1(foo, 3);
        if(th1.joinale())
        {
            th1.detach();
        }
        return 0;
    }
```

- `To Compile Thread used code , you have to write `**g++ -c file_to_compiled.cpp -o Output_compiled_file.o -pthread** The -pthread flag in the g++ command is used to enable multithreading with the POSIX threads (pthreads) library in Linux.

### Understanding Content-Type in HTTP Responses

When a web server sends a response to a web browser, it includes various headers that provide information about the response. One important header is the `Content-Type`. This header tells the browser what kind of content it is receiving, so the browser knows how to display it correctly.

#### Common Content-Types:

1. **text/html**: HTML content. The browser will render this as a web page.
2. **text/plain**: Plain text. The browser will display this as simple text.
3. **application/json**: JSON data. The browser or a web application will process this as JSON.
4. **image/jpeg**: JPEG image. The browser will display this as an image.
5. **application/octet-stream**: Binary data. The browser will typically prompt to download this file.

# HTTP Compression

- Whenever Browser sends request to web server it also mention which encoding or compression machanism it accepts , in accept part of HTTP request Header section.
  So, Basicaly it is a file compression mechanish used by web server to reduce the size of files they are serving for a request.
- Types of encoding mechanism Gzip,deflate , hoffman encoding etc.
- An HTTP client uses the Accept-Encoding header to specify the compression schemes it supports. In the following example, the client specifies that it supports the gzip compression scheme:

```
> GET /echo/foo HTTP/1.1
> Host: localhost:4221
> User-Agent: curl/7.81.0
> Accept: */*
> Accept-Encoding: gzip  // Client specifies it supports the gzip compression scheme.
```

The server then chooses one of the compression schemes listed in Accept-Encoding and compresses the response body with it.

Then, the server sends a response with the compressed body and a Content-Encoding header. Content-Encoding specifies the compression scheme that was used.

In the following example, the response body is compressed with gzip:

```
< HTTP/1.1 200 OK
< Content-Encoding: gzip    // Server specifies that the response body is compressed with gzip.
< Content-Type: text/plain  // Original media type of the body.
< Content-Length: 23        // Size of the compressed body.
< ...                       // Compressed body.
```

# Interview Prespective :

## Q1. Explain about your project ?

Ans : The project is implementation of Web Server or HTTP1/1.1 server. It handles HTTP GET and POST requests, provides responses based on the requeste , and supports gzip compression , multithreading to handel multiple concurrent operation at once and also provide feature of Etag generation or Entity Tag generation for web caching which improve overall server performance SO that server don't have to response to same request again and again.

It uses make file for easy compilation.

It includes features like serving static files, echoing back data, user-agent extraction, and basic file uploads.

## Q2. Why you uses CPP , what are its advantages

1. C++ provides high `performance and efficiency`. Given that HTTP servers often need to handle multiple requests per second and deal with substantial I/O operations, the low-level memory management and optimized compilation of C++ are significant advantages.

2. C++ supports `Object-Oriented Programming`, which allows for modular and maintainable code. This project utilizes classes (HttpRequestHandler, RequestUtil, ResponseUtil) to encapsulate different functionalities. This separation of concerns makes the codebase easier to understand, extend, and maintain.

3. C++’s `Standard Template Library (STL)` & many inbuilt library for hashinga and file copression, offers powerful data structures and algorithms that can simplify complex operations.`C++ has extensive libraries` and tools available for various tasks. The `project leverages zlib for gzip compression`, a widely used library in the C++ ecosystem for compression tasks.

4. C++ is suitable for `system-level programming`. This makes it an excellent choice for writing servers that may need to interact closely with the operating system, manage resources manually, and perform low-level tasks.

5. `C++ provides scalability` .C++ offers support for multi-threading and concurrency through libraries like the C++11 <thread> library . This allows for the server can handle multiple requests concurrently, improving throughput and responsiveness.

## Q3. WHy uses Linux insted of windows

Got it! Here's why Linux was chosen over Windows for developing and deploying the C++ HTTP server:

### Stability and Performance

**Stability**: Linux is renowned for its stability and reliability, particularly in server environments. Many high-availability systems and critical applications run on Linux due to its robust performance under heavy load.

**Performance**: Linux tends to have lower overhead than Windows, especially in server operations, which translates to better performance for networking and file I/O operations—key aspects for an HTTP server.

### Development Tools and Ecosystem

**Rich Development Ecosystem**:

- **GCC**: The GNU Compiler Collection is a powerful, widely-used compiler that is standard on most Linux distributions.
- **GDB**: The GNU Debugger is a robust tool for debugging C++ applications.
- **Make and CMake**: These build tools are well-integrated into the Linux ecosystem and are essential for managing complex builds.

**Package Management**:

- Linux distributions come with package managers (`apt` for Debian-based, `yum` or `dnf` for Red Hat-based) that simplify the installation and management of development tools and libraries, such as `zlib` for compression.

### Open Source and Community Support

**Open Source**: Linux is open source, providing greater flexibility, transparency, and control over the development environment. Developers can tweak the OS to better suit their needs if required.

**Community Support**: The Linux community is extensive and active. There's a wealth of resources, forums, and documentation available, making it easier to find solutions to problems and get support from other developers.

### Networking and Security

**Networking**:

- Linux has a powerful and flexible networking stack, which is crucial for developing networked applications like an HTTP server.
- Tools like `netstat`, `tcpdump`, and `ip` are invaluable for diagnosing and managing network connections and performance.

**Security**:

- Linux is often considered more secure than Windows, partly due to its open-source nature allowing thorough inspection and the extensive security tools available.
- Tools like `iptables`, SELinux, and AppArmor provide robust security features that help protect the server from various threats.

### Compatibility and Integration

**Server Environment Compatibility**: Most web servers and cloud environments run on Linux, ensuring that the development environment closely matches the production environment, reducing the chances of deployment issues.

**Integration with Other Services**:

- Linux integrates well with other open-source software commonly used in server environments, such as web servers (Apache, Nginx), databases (MySQL, PostgreSQL), and caching systems (Redis, Memcached).

### Resource Efficiency

**Resource Management**: Linux generally uses fewer resources than Windows, allowing more efficient use of CPU, memory, and disk space. This efficiency is critical for servers that need to handle high volumes of traffic.

### Example Workflow Using Linux Features

1. **Development and Compilation**:

   - Writing code in a powerful text editor like Vim or an IDE like VS Code.
   - Using GCC to compile the C++ code.
   - Utilizing `make` to manage build processes efficiently.

2. **Testing and Debugging**:

   - Running and testing the server locally.
   - Using tools like GDB for debugging and Valgrind for memory analysis.

3. **Deployment**:

   - Deploying the server on a Linux-based cloud instance (e.g., AWS EC2, DigitalOcean Droplet).
   - Configuring the server using system tools and scripting (e.g., Bash scripts).

4. **Monitoring and Maintenance**:
   - Using tools like `htop`, `netstat`, and `tcpdump` to monitor system performance and network traffic.
   - Automating maintenance tasks with cron jobs.

## Q3. What are the biggest challenges you faced during this project

### Biggest Challenges Faced During the Project

#### 1. **Handling HTTP Protocol Nuances**

- **Challenge**: Ensuring full compliance with HTTP/1.1 specifications, such as correctly parsing requests and forming responses.
- **Solution**: Extensive testing with various HTTP clients and using tools like Wireshark to analyze and debug the request-response flow.

#### 2. **Implementing Gzip Compression**

- **Challenge**: Efficiently compressing response data and handling edge cases where clients do not support gzip.
- **Solution**: Integrated zlib for compression and added logic to check the `Accept-Encoding` header to ensure compatibility.

#### 3. **Error Handling and Security**

- **Challenge**: Providing robust error handling and preventing common vulnerabilities like directory traversal and file inclusion.
- **Solution**: Implemented comprehensive error responses and sanitized file paths to ensure secure access.

#### 4. **Performance Optimization**

- **Challenge**: Achieving high performance with low latency, especially for file I/O operations.
- **Solution**: Optimized file reading and writing processes, minimized memory usage, and used efficient data structures.

#### 5. **Cross-Platform Compatibility**

- **Challenge**: Ensuring the server works seamlessly on different Linux distributions and potentially other operating systems.
- **Solution**: Focused on using portable libraries and adhering to cross-platform coding standards.

### Conclusion

These challenges were tackled through a combination of thorough testing, leveraging existing libraries, and maintaining a focus on security and performance, ultimately leading to a robust and efficient HTTP server.

## Q4. What are some feature

### Key Advantages of My Custom HTTP Server Over Apache/IIS

#### Customization and Flexibility

- **Tailored Functionality**: Designed to handle specific routes like `/user-agent` and `/echo/`, offering precise control over request handling.
- **Modular Design**: Easy to extend and maintain due to the clear separation of responsibilities.

#### Performance Optimization

- **Gzip Compression**: Reduces response sizes for faster transmission and better bandwidth utilization.
- **Efficient I/O**: Optimized file handling for lower latency and faster file serving.

#### Lightweight and Efficient

- **Minimal Dependencies**: Runs efficiently on lower-end hardware, ideal for embedded systems or resource-constrained environments.
- **Custom Implementation**: Stripped down to essential features, avoiding the overhead of unnecessary components.

#### Security and Stability

- **Robust Error Handling**: Provides clear and appropriate error responses, aiding in quick diagnostics.
- **Secure File Handling**: Mitigates risks like directory traversal attacks through careful handling.

#### Educational Value

- **Learning Experience**: Offers deep insights into HTTP protocols, request handling, and performance optimization, valuable for educational purposes.
